

## Imperative Programming (অনুজ্ঞাসূচক, বাধ্যতামূলক)

Imperative programming consists of sets of detailed instructions that are given to the computer to execute in a given order.
We're being <b>detailed and specific in our instructions</b>, and that's what imperative programming stands for.

## Procedural Programming (পদ্ধতিগত প্রোগ্রামিং)

Procedural programming is a <b>derivation of imperative programming</b>
In procedural programming, the user is encouraged to subdivide the program execution into functions, as a way of improving modularity and organization.

## Functional Programming

it takes the concept of functions a little bit further.

1. functions are treated as first-class citizens, meaning that they can be assigned to variables, passed as arguments, and returned from other functions.
2. A pure function is one that relies only on its inputs to generate its result. it produces no side effects (any change outside the function's environment).

## Declarative Programming

1. Declarative programming is all about hiding away complexity and bringing programming languages closer to human language and thinking.
2. It's the direct opposite of imperative programming
3. doesn't give instructions about how the computer should execute the task, but rather on what result is needed.
4. JavaScript's filter, map, reduce, sort and React JSX syntax functions are good examples of declarative code.
5. JSX syntax (what React uses) mixes HTML and JS in the same thing, which makes it easier and faster to write apps. But that's not what browsers read and execute. React code is later on transpiled into regular HTML and JS, and that's what browsers run in reality.
6. An important thing to notice about declarative programming is that under the hood, the computer processes this information as imperative code anyway.



## Object-oriented programming (অবজেক্ট ভিত্তিক)
1. OOP is a programming paradigm based on the concept of "objects"


## EVENT DRIVEN PROGRAMMING 
In computer programming, event-driven programming is a programming paradigm 
in which the flow of the program is determined by events such as user actions 
(mouse clicks, key presses), sensor outputs, or message passing from other 
programs or threads